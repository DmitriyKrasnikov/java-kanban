package Manager;

public class Managers {

    public static TaskManager getDefault(){
        return new InMemoryTaskManager();
    }

    public static HistoryManager getDefaultHistory(){
        return new InMemoryHistoryManager();
    }

}

/* Несмотря на то, что это ТЗ самое простое по решению, для меня оно оказалось самым сложным потому, что я не понимал,
что надо сделать и почему. Возникло много вопросов.
Я объединил TaskManager и EpicManager, так как не знаю, как сделать так, чтобы программа функционировала правильно, при
соблюдении ТЗ. Причина ниже. К тому же, не знаю какие могут быть довороты в будущем.

1. Утилитарный класс отличается от обычного только тем, что все его переменные и методы статические?
2. Нужны ли конструкторы в классах с названием InMemory? Я думаю, что, если никаких параметров не передавать создаваемому
объекту, то конструктор не нужен.
3. Основной вопрос. Он относится и к ТЗ и просто интересно, как это реализовать.
В ТЗ написано: "Managers должен сам подбирать нужную реализацию TaskManager и возвращать объект правильного типа... При
этом вызывающему неизвестен конкретный класс, только то, что объект, который возвращает getDefault(), реализует
интерфейс TaskManager". Как я это реализовал в коде, видно выше. Но как я это понял. Для начала, что я понимаю под реализацией
интерфейса:
  а) Когда есть один или несколько классов, которые имплементируют (реализуют) интерфейс. Например,
  InMemoryTaskManager, InMemoryTaskManager1, InMemoryTaskManager2 или же InMemoryTaskManager и InMemoryEpicManager.

  Если я правильно понял, то можно попробовать реализовать это через дженерики, но тогда не выполняется условие, что
  "вызывающему неизвестен конкретный класс", ведь при вызове метода getDefault(), необходимо будет указать тип параметра.
  Тогда возникает другой вывод, что понятие "реализация интерфейса", я понимаю неправильно. И понимать под
  "несколько реализаций интерфейса TaskManager" стоит:

  б) Создание нескольких объектов одного класса(в данном случае InMemoryTaskManager), который имплементирует (реализует)
  данный интерфейс.
  (Тогда я всё сделал правильно.)

  Но если описание "а)" - верное, то мне не хватает знаний как это всё воплотить. Или же просто некорректное ТЗ.

  4. Ну и метод getHistory(). Изначально он должен был находиться в InMemoryTaskManager и возвращать список просмотренных
  задач. Зачем он должен был их возвращать, когда надо всего лишь вывести? Сейчас он возвращает список из класса
  InMemoryHistoryManager, в этом случае понятно зачем, потому что список private, но в InMemoryTaskManager он по-прежнему
  пустой и выводит историю просмотров.

 */